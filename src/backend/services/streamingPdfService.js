import { generateTenantReport } from './pdfService.js';
import archiver from 'archiver';
import { Readable } from 'stream';

export class StreamingPdfGenerator {
    constructor(progressCallback = null) {
        this.progressCallback = progressCallback;
        this.processed = 0;
        this.total = 0;
        this.errors = [];
    }

    async generateBatchStream(tenantData, month, year) {
        this.total = tenantData.length;
        this.processed = 0;
        this.errors = [];

        // Create ZIP archive stream
        const archive = archiver('zip', {
            zlib: { level: 9 }, // Maximum compression
            forceLocalTime: true
        });

        // Handle archive events
        archive.on('warning', (err) => {
            if (err.code === 'ENOENT') {
                console.warn('Archive warning:', err);
            } else {
                throw err;
            }
        });

        archive.on('error', (err) => {
            throw err;
        });

        // Process tenants in batches to manage memory
        const batchSize = 3; // Process 3 PDFs at a time
        for (let i = 0; i < tenantData.length; i += batchSize) {
            const batch = tenantData.slice(i, i + batchSize);
            await this.processBatch(archive, batch, month, year);
        }

        // Add error summary if there were errors
        if (this.errors.length > 0) {
            const errorSummary = this.generateErrorSummary(month, year);
            archive.append(Buffer.from(errorSummary), { name: 'export_summary.txt' });
        }

        // Finalize the archive
        await archive.finalize();
        
        return archive;
    }

    async processBatch(archive, batch, month, year) {
        const promises = batch.map(tenantInfo => this.processTenat(tenantInfo, month, year));
        const results = await Promise.allSettled(promises);

        for (let i = 0; i < results.length; i++) {
            const result = results[i];
            const tenantInfo = batch[i];

            if (result.status === 'fulfilled' && result.value) {
                // Add PDF to archive
                const filename = this.generateSafeFilename(tenantInfo.tenant, month, year);
                archive.append(result.value, { name: filename });
                
                this.updateProgress(`Completed ${tenantInfo.tenant.name} ${tenantInfo.tenant.surname}`);
            } else {
                // Handle error
                const error = result.reason || new Error('Unknown error');
                this.errors.push(`Failed to generate report for ${tenantInfo.tenant.name} ${tenantInfo.tenant.surname}: ${error.message}`);
                this.updateProgress(`Error processing ${tenantInfo.tenant.name} ${tenantInfo.tenant.surname}`);
            }

            this.processed++;
        }
    }

    async processTenat(tenantInfo, month, year) {
        try {
            const { tenant, utilities } = tenantInfo;
            
            const progressCallback = (stage, data) => {
                if (this.progressCallback) {
                    this.progressCallback('pdf_stage', {
                        stage,
                        tenant: `${tenant.name} ${tenant.surname}`,
                        ...data
                    });
                }
            };

            const pdfBuffer = await generateTenantReport(
                tenant, 
                month, 
                year, 
                utilities, 
                { progressCallback }
            );

            return pdfBuffer;
        } catch (error) {
            throw error;
        }
    }

    generateSafeFilename(tenant, month, year) {
        const safeName = tenant.name.replace(/[^a-zA-Z0-9]/g, '');
        const safeSurname = tenant.surname.replace(/[^a-zA-Z0-9]/g, '');
        return `${safeName}_${safeSurname}_${month}_${year}.pdf`;
    }

    generateErrorSummary(month, year) {
        const successCount = this.processed - this.errors.length;
        return `Batch Export Summary - ${month}/${year}

Export completed: ${new Date().toLocaleString()}
Successfully processed: ${successCount}/${this.total} reports

${this.errors.length > 0 ? 'Errors encountered:\n' + this.errors.map((err, i) => `${i + 1}. ${err}`).join('\n') : 'No errors encountered.'}

Generated by Property Management System v1.0`;
    }

    updateProgress(message) {
        if (this.progressCallback) {
            this.progressCallback('progress', {
                current: this.processed,
                total: this.total,
                message
            });
        }
    }
}

// Memory-efficient PDF streaming for large batches
export class MemoryEfficientPdfStream {
    constructor(maxConcurrent = 2) {
        this.maxConcurrent = maxConcurrent;
        this.activeStreams = 0;
        this.queue = [];
    }

    async generatePdfStream(tenant, month, year, utilities) {
        return new Promise((resolve, reject) => {
            this.queue.push({ tenant, month, year, utilities, resolve, reject });
            this.processQueue();
        });
    }

    async processQueue() {
        if (this.activeStreams >= this.maxConcurrent || this.queue.length === 0) {
            return;
        }

        const { tenant, month, year, utilities, resolve, reject } = this.queue.shift();
        this.activeStreams++;

        try {
            // Use streaming mode for memory efficiency
            const pdfDoc = await generateTenantReport(tenant, month, year, utilities, { 
                streaming: true 
            });

            // Create readable stream from PDF document
            const pdfStream = new Readable({
                read() {}
            });

            pdfDoc.on('data', chunk => pdfStream.push(chunk));
            pdfDoc.on('end', () => {
                pdfStream.push(null);
                this.activeStreams--;
                this.processQueue(); // Process next item in queue
            });
            pdfDoc.on('error', err => {
                pdfStream.destroy(err);
                this.activeStreams--;
                this.processQueue();
            });

            // Start PDF generation
            pdfDoc.end();

            resolve(pdfStream);
        } catch (error) {
            this.activeStreams--;
            this.processQueue();
            reject(error);
        }
    }
}

// Utility for chunked processing with backpressure handling
export class ChunkedProcessor {
    static async processInChunks(items, processor, chunkSize = 5, delayMs = 100) {
        const results = [];
        
        for (let i = 0; i < items.length; i += chunkSize) {
            const chunk = items.slice(i, i + chunkSize);
            const chunkResults = await Promise.allSettled(
                chunk.map(item => processor(item))
            );
            
            results.push(...chunkResults);
            
            // Add small delay to prevent overwhelming the system
            if (i + chunkSize < items.length && delayMs > 0) {
                await new Promise(resolve => setTimeout(resolve, delayMs));
            }
        }
        
        return results;
    }
}

export default {
    StreamingPdfGenerator,
    MemoryEfficientPdfStream,
    ChunkedProcessor
};